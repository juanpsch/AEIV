# -*- coding: utf-8 -*-
"""ae_aco_01.ipynb

Automatically generated by Colab.

Original file is located at
 
"""

# -------------------------------------------------------------------------
# Optimizacion por colonia de hormigas
# ejemplo del viajante de comercio (TSP) para 5 ciudades
# -------------------------------------------------------------------------
import numpy as np


# -------------------------------------------------------------------------
# configuracion del problema del viajante (5 ciudades)
# -------------------------------------------------------------------------
distancias = np.array([[0, 2, 9, 10, 7],      # matriz de distancias entre 5 ciudades
                       [2, 0, 6, 4, 3],       # cada fila es una ciudad y cada columna tambine
                       [9, 6, 0, 8, 5],       # [1,1] la distancia de city 1 a city 1 es 0
                       [10, 4, 8, 0, 6],      # [1, 3] la distancia de city 1 a city 3 es 9
                       [7, 3, 5, 6, 0]])


# -------------------------------------------------------------------------
# parametros del algoritmo ACO
# -------------------------------------------------------------------------
num_hormigas = 10       # Numero de hormigas
num_iteraciones = 100   # Numero de iteraciones
alpha = 2.0             # Influencia de las feromonas
beta = 5.0              # Influencia de la heurística (inversa de la distancia)
rho = 0.9               # Factor de evaporación de feromonas
Q = 100                 # Constante para el deposito de feromonas


# -------------------------------------------------------------------------
# inicializacion de feromonas
# -------------------------------------------------------------------------
num_ciudades = distancias.shape[0]            # Numero de ciudades (5)
feromonas = np.ones((num_ciudades, num_ciudades))  # Inicializar matriz de feromonas a 1


# -------------------------------------------------------------------------
# se calcula la probabilidad de moverse a la siguiente ciudad
# -------------------------------------------------------------------------
def calcular_probabilidad(ciudad_actual, ciudades_visitadas, feromonas, distancias, alpha, beta):
    numeradores = []    # Lista para almacenar el valor del numerador
    denominador = 0      # Inicializacion del denominador a 0

    # se calcula numeradores y el denominador
    for ciudad in range(num_ciudades):      # Iterar por todas las ciudades
        if ciudad not in ciudades_visitadas:  # Solo considerar ciudades no visitadas
            tau = feromonas[ciudad_actual, ciudad] ** alpha  # Influencia de las feromonas
            eta = (1 / distancias[ciudad_actual, ciudad]) ** beta  # Influencia de la heuristica
            probabilidad = tau * eta         # Calcular la probabilidad
            numeradores.append(probabilidad) # agregar al numerador
            denominador += probabilidad      # Sumar al denominador
        else:
            numeradores.append(0)            # Si ya fue visitada, probabilidad 0

    # Calcular las probabilidades finales
    probabilidades = []    # Lista para almacenar las probabilidades finales
    for numerador in numeradores:  # Iterar sobre los numeradores calculados
        if denominador > 0:
            probabilidades.append(numerador / denominador)  # Calcular la probabilidad si denominador > 0
        else:
            probabilidades.append(0)    # Si denominador es 0, probabilidad 0

    return probabilidades               # Devolver la lista de probabilidades


# -------------------------------------------------------------------------
# funcion para que una hormiga construya una solución (recorrido)
# -------------------------------------------------------------------------
def construir_solucion(feromonas, distancias, alpha, beta):
    recorrido = []     # Lista para almacenar el recorrido de la hormiga
    ciudad_actual = np.random.randint(0, num_ciudades)  # se elige una ciudad inicial al azar
    recorrido.append(ciudad_actual)   # se agrega la ciudad inicial al recorrido

    while len(recorrido) < num_ciudades:    # Continuar hasta que todas las ciudades sean visitadas
        probabilidades = calcular_probabilidad(ciudad_actual, recorrido, feromonas, distancias, alpha, beta)
        ciudad_siguiente = np.random.choice(range(num_ciudades), p=probabilidades)  # se elege la siguiente ciudad basada en probabilidades
        recorrido.append(ciudad_siguiente)  # se agrega la ciudad siguiente al recorrido
        ciudad_actual = ciudad_siguiente    # se ctualiza la ciudad actual

    return recorrido   # se devuelve el recorrido construido por la hormiga


# -------------------------------------------------------------------------
# funcon para calcular la longitud total de un recorrido
# -------------------------------------------------------------------------
def calcular_longitud_recorrido(recorrido, distancias):
    longitud = 0   # Inicializar longitud a 0
    for i in range(len(recorrido) - 1):  # Calcular la longitud entre ciudades consecutivas que eligio la hormiga recorrer
        longitud += distancias[recorrido[i], recorrido[i+1]]
    longitud += distancias[recorrido[-1], recorrido[0]]  # vuelve a la ciudad inicial
    return longitud   # se devuelve la longitud total del recorrido


# -------------------------------------------------------------------------
# funcion para actualizar las feromonas
# -------------------------------------------------------------------------
def actualizar_feromonas(feromonas, hormigas, distancias, rho, Q):
    feromonas *= (1 - rho)  # Evaporacion de feromonas (reducir el nivel en todas las aristas o arcos del grafo)
    for recorrido in hormigas:   # para cada recorrido de las hormigas
        longitud = calcular_longitud_recorrido(recorrido, distancias)  # Calcular la longitud del recorrido
        for i in range(len(recorrido) - 1):  # deposito de feromonas en los arcos utilzadas del grafo
            feromonas[recorrido[i], recorrido[i+1]] += Q / longitud
            feromonas[recorrido[i+1], recorrido[i]] += Q / longitud  # Es un grafo no dirigido


# -------------------------------------------------------------------------
# Algoritmo principal ACO
# -------------------------------------------------------------------------
mejor_recorrido = None        # se inicializa el mejor recorrido
mejor_longitud = float('inf') # se inicializa la mejor longitud como infinito

for iteracion in range(num_iteraciones):
    hormigas = []   # lista para almacenar los recorridos de las hormigas

    # cada hormiga construye una solución
    for _ in range(num_hormigas):    # para cada hormiga
        recorrido = construir_solucion(feromonas, distancias, alpha, beta)  # Construccion  del recorrido
        hormigas.append(recorrido)    # se agrega el recorrido a la lista de hormigas

    # se actualizan las feromonas
    actualizar_feromonas(feromonas, hormigas, distancias, rho, Q)  # Actualizacion del nivel de feromonas

    # se verifica si alguna hormiga encontró una mejor solución
    for recorrido in hormigas:     # para cada recorrido de las hormigas
        longitud = calcular_longitud_recorrido(recorrido, distancias)  # se calcula la longitud
        if longitud < mejor_longitud:  # si se encuentra una mejor longitud
            mejor_longitud = longitud   # se actualiza la mejor longitud
            mejor_recorrido = recorrido # tambein se actualiza el mejor recorrido

    print(f"iteracion: {iteracion+1}, mejor longitud: {mejor_longitud}")  # se imprime por consola el progreso de cada iteración


# -------------------------------------------------------------------------
# Mostrar el mejor recorrido encontrado
# -------------------------------------------------------------------------
print(f"\mMejor recorrido encontrado: {mejor_recorrido}")  # se imprime el mejor recorrido
print(f"con longitud: {mejor_longitud}")  # se imprime la mejor longitud